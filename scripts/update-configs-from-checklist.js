#!/usr/bin/env node

/**
 * Configuration Update Script
 * Updates Discord configuration files based on the channel checklist
 * generated by discover-channels.js
 *
 * Usage:
 * - npm run update-configs
 * - node scripts/update-configs-from-checklist.js --dry-run
 */

const fs = require('fs');
const path = require('path');
require('dotenv').config();

// Configuration
const CHECKLIST_FILE = './scripts/CHANNELS.md';
const CONFIG_DIR = './config';
const BACKUP_DIR = './config/backup';

class ConfigUpdater {
  constructor() {
    this.dryRun = process.argv.includes('--dry-run');
    this.verbose = process.argv.includes('--verbose');
    this.changes = new Map(); // configFile -> changes
  }

  /**
   * Parse the markdown checklist to extract channel selections
   * Supports both old list format and new table format
   * Also parses Recommendations section and maps to correct guilds
   */
  parseChecklist() {
    console.log('ðŸ“‹ Parsing channel checklist...');

    if (!fs.existsSync(CHECKLIST_FILE)) {
      throw new Error(`Checklist file not found: ${CHECKLIST_FILE}`);
    }

    const content = fs.readFileSync(CHECKLIST_FILE, 'utf8');
    const lines = content.split('\n');

    const guildChannels = new Map(); // guildId -> { guildName, checkedChannels, uncheckedChannels, mutedChannels }
    const channelToGuild = new Map(); // channelId -> guildId (for recommendations lookup)
    const pendingRecommendations = []; // Store recommendations to process after guilds
    let currentGuild = null;
    let currentGuildId = null;
    let inRecommendations = false;

    for (const line of lines) {
      // Detect Recommendations section
      if (line.includes('## ðŸ”¥ Recommendations')) {
        inRecommendations = true;
        continue;
      }

      // Match guild headers: ## Guild Name (new format) or ### Guild Name (old format)
      const guildMatch = line.match(/^##+ ([^*\n]+)$/);
      if (guildMatch && !line.includes('Summary') && !line.includes('Recommendations') && !line.includes('Instructions') && !line.includes('Legend')) {
        currentGuild = guildMatch[1].trim();
        inRecommendations = false; // Exit recommendations section
        continue;
      }

      // Match guild ID: *Guild ID: `123456789`*
      const guildIdMatch = line.match(/\*Guild ID: `([^`]+)`\*/);
      if (guildIdMatch && currentGuild) {
        currentGuildId = guildIdMatch[1];
        guildChannels.set(currentGuildId, {
          guildName: currentGuild,
          checkedChannels: [],
          uncheckedChannels: [],
          mutedChannels: []
        });
        continue;
      }

      // NEW FORMAT: Match table rows with emoji checkboxes (âœ…/â¬œ) or old format ([x]/[ ])
      // Format with activity: | #channel-name | `channelId` | ðŸ”¥ 45/day | âœ… | â¬œ |
      // Format without activity: | #channel-name | `channelId` | âœ… | â¬œ |
      const tableMatchWithActivity = line.match(/^\|\s*#([^|]+)\|\s*`(\d+)`\s*\|[^|]*\|\s*(âœ…|â¬œ|\[[x ]\])\s*\|\s*(âœ…|â¬œ|\[[x ]\])\s*\|/);
      const tableMatchNoActivity = line.match(/^\|\s*#([^|]+)\|\s*`(\d+)`\s*\|\s*(âœ…|â¬œ|\[[x ]\])\s*\|\s*(âœ…|â¬œ|\[[x ]\])\s*\|/);

      const tableMatch = tableMatchWithActivity || tableMatchNoActivity;
      if (tableMatch) {
        const [, channelName, channelId, trackChecked, muteChecked] = tableMatch;
        // Normalize: âœ… or [x] means checked
        const isTrackChecked = trackChecked === 'âœ…' || trackChecked === '[x]';
        const isMuteChecked = muteChecked === 'âœ…' || muteChecked === '[x]';

        if (inRecommendations) {
          // Store for later processing after we know all guilds
          pendingRecommendations.push({ channelId, channelName: channelName.trim(), isTrackChecked, isMuteChecked });
        } else if (currentGuildId) {
          const guildData = guildChannels.get(currentGuildId);
          // Track channel -> guild mapping for recommendations
          channelToGuild.set(channelId, currentGuildId);

          if (isMuteChecked) {
            guildData.mutedChannels.push({ channelId, channelName: channelName.trim() });
          } else if (isTrackChecked) {
            guildData.checkedChannels.push({ channelId, channelName: channelName.trim() });
          } else {
            guildData.uncheckedChannels.push({ channelId, channelName: channelName.trim() });
          }
        }
        continue;
      }

      // OLD FORMAT: Match channel entries: - [x] or - [ ] **#channel-name** (`channelId`)
      const listMatch = line.match(/^- \[([x ])\] \*\*#([^*]+)\*\* \(`([^)]+)`\)/);
      if (listMatch && currentGuildId) {
        const [, checked, channelName, channelId] = listMatch;
        const guildData = guildChannels.get(currentGuildId);
        channelToGuild.set(channelId, currentGuildId);

        if (checked === 'x') {
          guildData.checkedChannels.push({ channelId, channelName });
        } else {
          guildData.uncheckedChannels.push({ channelId, channelName });
        }
      }
    }

    // Process pending recommendations - find their guilds and apply changes
    let recommendationsApplied = 0;
    for (const rec of pendingRecommendations) {
      const guildId = channelToGuild.get(rec.channelId);
      if (guildId) {
        const guildData = guildChannels.get(guildId);
        // Only apply if Track or Mute is checked (recommendations default to unchecked)
        if (rec.isMuteChecked) {
          // Remove from other lists if present, add to muted
          guildData.checkedChannels = guildData.checkedChannels.filter(c => c.channelId !== rec.channelId);
          guildData.uncheckedChannels = guildData.uncheckedChannels.filter(c => c.channelId !== rec.channelId);
          if (!guildData.mutedChannels.find(c => c.channelId === rec.channelId)) {
            guildData.mutedChannels.push({ channelId: rec.channelId, channelName: rec.channelName });
          }
          recommendationsApplied++;
        } else if (rec.isTrackChecked) {
          // Remove from other lists if present, add to checked
          guildData.mutedChannels = guildData.mutedChannels.filter(c => c.channelId !== rec.channelId);
          guildData.uncheckedChannels = guildData.uncheckedChannels.filter(c => c.channelId !== rec.channelId);
          if (!guildData.checkedChannels.find(c => c.channelId === rec.channelId)) {
            guildData.checkedChannels.push({ channelId: rec.channelId, channelName: rec.channelName });
          }
          recommendationsApplied++;
        }
      }
    }

    // Log summary
    let totalMuted = 0;
    for (const [, guildData] of guildChannels) {
      totalMuted += guildData.mutedChannels?.length || 0;
    }
    console.log(`âœ“ Parsed ${guildChannels.size} guilds from checklist`);
    if (recommendationsApplied > 0) {
      console.log(`ðŸ“Œ Applied ${recommendationsApplied} changes from Recommendations section`);
    }
    if (totalMuted > 0) {
      console.log(`ðŸ”‡ Found ${totalMuted} muted channels (will be ignored)\n`);
    } else {
      console.log('');
    }

    return guildChannels;
  }

  /**
   * Load all Discord configuration files
   */
  loadConfigs() {
    console.log('ðŸ“‚ Loading configuration files...');
    
    const configs = new Map();
    
    if (!fs.existsSync(CONFIG_DIR)) {
      throw new Error(`Config directory not found: ${CONFIG_DIR}`);
    }

    const configFiles = fs.readdirSync(CONFIG_DIR)
      .filter(file => file.endsWith('.json'));

    for (const configFile of configFiles) {
      try {
        const configPath = path.join(CONFIG_DIR, configFile);
        const config = JSON.parse(fs.readFileSync(configPath, 'utf8'));
        
        // Find Discord sources
        const discordSources = config.sources?.filter(source => 
          source.type === 'DiscordRawDataSource'
        ) || [];

        if (discordSources.length > 0) {
          configs.set(configFile, {
            path: configPath,
            config,
            discordSources
          });
          
          console.log(`âœ“ Loaded ${configFile}: ${discordSources.length} Discord source(s)`);
        } else {
          if (this.verbose) {
            console.log(`âš ï¸  Skipped ${configFile}: No Discord sources found`);
          }
        }
      } catch (error) {
        console.error(`âŒ Failed to load ${configFile}: ${error.message}`);
      }
    }
    
    console.log(`ðŸ“‹ Loaded ${configs.size} configurations with Discord sources\n`);
    return configs;
  }

  /**
   * Update configuration files based on checklist selections
   */
  updateConfigs(guildChannels, configs) {
    console.log('ðŸ”„ Updating configurations...');
    
    let totalUpdates = 0;
    
    for (const [configFile, configData] of configs) {
      const { config, discordSources } = configData;
      let configUpdated = false;
      const configChanges = {
        added: [],
        removed: [],
        sources: []
      };

      for (const source of discordSources) {
        // Get guild ID for this source
        const guildIdVar = source.params?.guildId?.replace('process.env.', '');
        const guildId = guildIdVar ? process.env[guildIdVar] : source.params?.guildId;
        
        if (!guildId) {
          console.log(`âš ï¸  Cannot determine guild ID for source ${source.name} in ${configFile}`);
          continue;
        }

        const guildData = guildChannels.get(guildId);
        if (!guildData) {
          console.log(`âš ï¸  No checklist data found for guild ${guildId} (${source.name})`);
          continue;
        }

        // Current channels in config
        const currentChannels = new Set(source.params?.channelIds || []);
        
        // Channels that should be tracked (checked in list)
        const shouldTrack = new Set(guildData.checkedChannels.map(ch => ch.channelId));
        
        // Calculate changes
        const toAdd = [...shouldTrack].filter(id => !currentChannels.has(id));
        const toRemove = [...currentChannels].filter(id => !shouldTrack.has(id));
        
        if (toAdd.length > 0 || toRemove.length > 0) {
          configUpdated = true;
          
          // Update the source
          if (!source.params) source.params = {};
          source.params.channelIds = [...shouldTrack];
          
          // Track changes
          const sourceChange = {
            sourceName: source.name,
            guildName: guildData.guildName,
            added: toAdd.map(id => {
              const ch = guildData.checkedChannels.find(c => c.channelId === id);
              return { channelId: id, channelName: ch?.channelName || 'Unknown' };
            }),
            removed: toRemove.map(id => {
              const ch = guildData.uncheckedChannels.find(c => c.channelId === id);
              return { channelId: id, channelName: ch?.channelName || 'Unknown' };
            }),
            totalChannels: shouldTrack.size
          };
          
          configChanges.sources.push(sourceChange);
          configChanges.added.push(...sourceChange.added);
          configChanges.removed.push(...sourceChange.removed);
        }
      }

      if (configUpdated) {
        this.changes.set(configFile, configChanges);
        totalUpdates++;
        
        console.log(`ðŸ“ ${configFile}:`);
        for (const sourceChange of configChanges.sources) {
          console.log(`  â””â”€ ${sourceChange.sourceName} (${sourceChange.guildName}):`);
          console.log(`     ðŸ“Š Total channels: ${sourceChange.totalChannels}`);
          
          if (sourceChange.added.length > 0) {
            console.log(`     âž• Added ${sourceChange.added.length} channels:`);
            for (const ch of sourceChange.added) {
              console.log(`        - #${ch.channelName} (${ch.channelId})`);
            }
          }
          
          if (sourceChange.removed.length > 0) {
            console.log(`     âž– Removed ${sourceChange.removed.length} channels:`);
            for (const ch of sourceChange.removed) {
              console.log(`        - #${ch.channelName} (${ch.channelId})`);
            }
          }
        }
        console.log('');
      }
    }

    console.log(`ðŸ“Š Summary: ${totalUpdates} configuration files will be updated\n`);
    
    if (totalUpdates === 0) {
      console.log('âœ¨ No changes needed! All configurations are already in sync with the checklist.');
      return false;
    }
    
    return true;
  }

  /**
   * Create backup of configuration files
   */
  createBackup(configs) {
    console.log('ðŸ’¾ Creating configuration backups...');
    
    if (!fs.existsSync(BACKUP_DIR)) {
      fs.mkdirSync(BACKUP_DIR, { recursive: true });
    }

    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    
    for (const [configFile] of this.changes) {
      const configData = configs.get(configFile);
      const backupFile = `${configFile}.${timestamp}.backup`;
      const backupPath = path.join(BACKUP_DIR, backupFile);
      
      fs.copyFileSync(configData.path, backupPath);
      console.log(`âœ“ Backed up ${configFile} to ${backupFile}`);
    }
    
    console.log('');
  }

  /**
   * Save updated configuration files
   */
  saveConfigs(configs) {
    console.log('ðŸ’¾ Saving updated configurations...');
    
    for (const [configFile] of this.changes) {
      const configData = configs.get(configFile);
      const updatedJson = JSON.stringify(configData.config, null, 2);
      
      fs.writeFileSync(configData.path, updatedJson, 'utf8');
      console.log(`âœ“ Saved ${configFile}`);
    }
    
    console.log('');
  }

  /**
   * Generate summary report
   */
  generateSummary() {
    console.log('ðŸ“Š Configuration Update Summary\n');
    
    let totalAdded = 0;
    let totalRemoved = 0;
    let totalSources = 0;
    
    for (const [configFile, changes] of this.changes) {
      console.log(`ðŸ“ ${configFile}:`);
      console.log(`   Sources updated: ${changes.sources.length}`);
      console.log(`   Channels added: ${changes.added.length}`);
      console.log(`   Channels removed: ${changes.removed.length}`);
      
      totalAdded += changes.added.length;
      totalRemoved += changes.removed.length;
      totalSources += changes.sources.length;
      console.log('');
    }
    
    console.log(`ðŸŽ¯ Overall Changes:`);
    console.log(`   ðŸ“„ Configuration files updated: ${this.changes.size}`);
    console.log(`   ðŸ”Œ Discord sources updated: ${totalSources}`);
    console.log(`   âž• Total channels added: ${totalAdded}`);
    console.log(`   âž– Total channels removed: ${totalRemoved}`);
    console.log(`   ðŸ”„ Net channel change: ${totalAdded - totalRemoved > 0 ? '+' : ''}${totalAdded - totalRemoved}`);
  }
}

/**
 * Main execution function
 */
async function main() {
  const updater = new ConfigUpdater();

  try {
    console.log(`ðŸš€ Configuration Update Tool ${updater.dryRun ? '(DRY RUN MODE)' : ''}\n`);
    
    // Parse checklist
    const guildChannels = updater.parseChecklist();
    
    // Load configurations
    const configs = updater.loadConfigs();
    
    if (configs.size === 0) {
      console.log('âŒ No Discord configurations found to update');
      process.exit(1);
    }
    
    // Update configurations
    const hasChanges = updater.updateConfigs(guildChannels, configs);
    
    if (!hasChanges) {
      console.log('âœ… Configuration update complete (no changes needed)');
      return;
    }
    
    if (updater.dryRun) {
      console.log('ðŸ§ª DRY RUN: No files were actually modified');
      updater.generateSummary();
      console.log('\nðŸ’¡ Run without --dry-run to apply these changes');
      return;
    }
    
    // Create backups and save
    updater.createBackup(configs);
    updater.saveConfigs(configs);
    
    // Generate summary
    updater.generateSummary();
    
    console.log('\nâœ¨ Configuration update complete!');
    console.log('\nðŸ“‹ Next steps:');
    console.log('1. Review the updated configuration files');
    console.log('2. Test your data collection with the new channel selections');
    console.log('3. Commit the changes to your repository');
    
  } catch (error) {
    console.error(`\nâŒ Update failed: ${error.message}`);
    process.exit(1);
  }
}

// Handle graceful shutdown
process.on('SIGINT', () => {
  console.log('\nðŸ‘‹ Update cancelled by user');
  process.exit(0);
});

if (require.main === module) {
  main();
}