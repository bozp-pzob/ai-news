#!/usr/bin/env node

/**
 * Configuration Update Script
 * Updates Discord configuration files based on the channel checklist
 * generated by discover-channels.js
 * 
 * Usage:
 * - npm run update-configs
 * - node scripts/update-configs-from-checklist.js --dry-run
 */

const fs = require('fs');
const path = require('path');

// Configuration
const CHECKLIST_FILE = './scripts/CHANNELS.md';
const CONFIG_DIR = './config';
const BACKUP_DIR = './config/backup';

class ConfigUpdater {
  constructor() {
    this.dryRun = process.argv.includes('--dry-run');
    this.verbose = process.argv.includes('--verbose');
    this.changes = new Map(); // configFile -> changes
  }

  /**
   * Parse the markdown checklist to extract channel selections
   */
  parseChecklist() {
    console.log('üìã Parsing channel checklist...');
    
    if (!fs.existsSync(CHECKLIST_FILE)) {
      throw new Error(`Checklist file not found: ${CHECKLIST_FILE}`);
    }

    const content = fs.readFileSync(CHECKLIST_FILE, 'utf8');
    const lines = content.split('\n');
    
    const guildChannels = new Map(); // guildId -> { guildName, checkedChannels, uncheckedChannels }
    let currentGuild = null;
    let currentGuildId = null;

    for (const line of lines) {
      // Match guild headers: ### Guild Name
      const guildMatch = line.match(/^### (.+)$/);
      if (guildMatch) {
        currentGuild = guildMatch[1];
        continue;
      }

      // Match guild ID: *Guild ID: `123456789`*
      const guildIdMatch = line.match(/\*Guild ID: `([^`]+)`\*/);
      if (guildIdMatch && currentGuild) {
        currentGuildId = guildIdMatch[1];
        guildChannels.set(currentGuildId, {
          guildName: currentGuild,
          checkedChannels: [],
          uncheckedChannels: []
        });
        continue;
      }

      // Match channel entries: - [x] or - [ ] **#channel-name** (`channelId`)
      const channelMatch = line.match(/^- \[([x ])\] \*\*#([^*]+)\*\* \(`([^)]+)`\)/);
      if (channelMatch && currentGuildId) {
        const [, checked, channelName, channelId] = channelMatch;
        const guildData = guildChannels.get(currentGuildId);
        
        if (checked === 'x') {
          guildData.checkedChannels.push({ channelId, channelName });
        } else {
          guildData.uncheckedChannels.push({ channelId, channelName });
        }
      }
    }

    console.log(`‚úì Parsed ${guildChannels.size} guilds from checklist\n`);
    return guildChannels;
  }

  /**
   * Load all Discord configuration files
   */
  loadConfigs() {
    console.log('üìÇ Loading configuration files...');
    
    const configs = new Map();
    
    if (!fs.existsSync(CONFIG_DIR)) {
      throw new Error(`Config directory not found: ${CONFIG_DIR}`);
    }

    const configFiles = fs.readdirSync(CONFIG_DIR)
      .filter(file => file.endsWith('.json'));

    for (const configFile of configFiles) {
      try {
        const configPath = path.join(CONFIG_DIR, configFile);
        const config = JSON.parse(fs.readFileSync(configPath, 'utf8'));
        
        // Find Discord sources
        const discordSources = config.sources?.filter(source => 
          source.type === 'DiscordRawDataSource'
        ) || [];

        if (discordSources.length > 0) {
          configs.set(configFile, {
            path: configPath,
            config,
            discordSources
          });
          
          console.log(`‚úì Loaded ${configFile}: ${discordSources.length} Discord source(s)`);
        } else {
          if (this.verbose) {
            console.log(`‚ö†Ô∏è  Skipped ${configFile}: No Discord sources found`);
          }
        }
      } catch (error) {
        console.error(`‚ùå Failed to load ${configFile}: ${error.message}`);
      }
    }
    
    console.log(`üìã Loaded ${configs.size} configurations with Discord sources\n`);
    return configs;
  }

  /**
   * Update configuration files based on checklist selections
   */
  updateConfigs(guildChannels, configs) {
    console.log('üîÑ Updating configurations...');
    
    let totalUpdates = 0;
    
    for (const [configFile, configData] of configs) {
      const { config, discordSources } = configData;
      let configUpdated = false;
      const configChanges = {
        added: [],
        removed: [],
        sources: []
      };

      for (const source of discordSources) {
        // Get guild ID for this source
        const guildIdVar = source.params?.guildId?.replace('process.env.', '');
        const guildId = guildIdVar ? process.env[guildIdVar] : source.params?.guildId;
        
        if (!guildId) {
          console.log(`‚ö†Ô∏è  Cannot determine guild ID for source ${source.name} in ${configFile}`);
          continue;
        }

        const guildData = guildChannels.get(guildId);
        if (!guildData) {
          console.log(`‚ö†Ô∏è  No checklist data found for guild ${guildId} (${source.name})`);
          continue;
        }

        // Current channels in config
        const currentChannels = new Set(source.params?.channelIds || []);
        
        // Channels that should be tracked (checked in list)
        const shouldTrack = new Set(guildData.checkedChannels.map(ch => ch.channelId));
        
        // Calculate changes
        const toAdd = [...shouldTrack].filter(id => !currentChannels.has(id));
        const toRemove = [...currentChannels].filter(id => !shouldTrack.has(id));
        
        if (toAdd.length > 0 || toRemove.length > 0) {
          configUpdated = true;
          
          // Update the source
          if (!source.params) source.params = {};
          source.params.channelIds = [...shouldTrack];
          
          // Track changes
          const sourceChange = {
            sourceName: source.name,
            guildName: guildData.guildName,
            added: toAdd.map(id => {
              const ch = guildData.checkedChannels.find(c => c.channelId === id);
              return { channelId: id, channelName: ch?.channelName || 'Unknown' };
            }),
            removed: toRemove.map(id => {
              const ch = guildData.uncheckedChannels.find(c => c.channelId === id);
              return { channelId: id, channelName: ch?.channelName || 'Unknown' };
            }),
            totalChannels: shouldTrack.size
          };
          
          configChanges.sources.push(sourceChange);
          configChanges.added.push(...sourceChange.added);
          configChanges.removed.push(...sourceChange.removed);
        }
      }

      if (configUpdated) {
        this.changes.set(configFile, configChanges);
        totalUpdates++;
        
        console.log(`üìù ${configFile}:`);
        for (const sourceChange of configChanges.sources) {
          console.log(`  ‚îî‚îÄ ${sourceChange.sourceName} (${sourceChange.guildName}):`);
          console.log(`     üìä Total channels: ${sourceChange.totalChannels}`);
          
          if (sourceChange.added.length > 0) {
            console.log(`     ‚ûï Added ${sourceChange.added.length} channels:`);
            for (const ch of sourceChange.added) {
              console.log(`        - #${ch.channelName} (${ch.channelId})`);
            }
          }
          
          if (sourceChange.removed.length > 0) {
            console.log(`     ‚ûñ Removed ${sourceChange.removed.length} channels:`);
            for (const ch of sourceChange.removed) {
              console.log(`        - #${ch.channelName} (${ch.channelId})`);
            }
          }
        }
        console.log('');
      }
    }

    console.log(`üìä Summary: ${totalUpdates} configuration files will be updated\n`);
    
    if (totalUpdates === 0) {
      console.log('‚ú® No changes needed! All configurations are already in sync with the checklist.');
      return false;
    }
    
    return true;
  }

  /**
   * Create backup of configuration files
   */
  createBackup(configs) {
    console.log('üíæ Creating configuration backups...');
    
    if (!fs.existsSync(BACKUP_DIR)) {
      fs.mkdirSync(BACKUP_DIR, { recursive: true });
    }

    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    
    for (const [configFile] of this.changes) {
      const configData = configs.get(configFile);
      const backupFile = `${configFile}.${timestamp}.backup`;
      const backupPath = path.join(BACKUP_DIR, backupFile);
      
      fs.copyFileSync(configData.path, backupPath);
      console.log(`‚úì Backed up ${configFile} to ${backupFile}`);
    }
    
    console.log('');
  }

  /**
   * Save updated configuration files
   */
  saveConfigs(configs) {
    console.log('üíæ Saving updated configurations...');
    
    for (const [configFile] of this.changes) {
      const configData = configs.get(configFile);
      const updatedJson = JSON.stringify(configData.config, null, 2);
      
      fs.writeFileSync(configData.path, updatedJson, 'utf8');
      console.log(`‚úì Saved ${configFile}`);
    }
    
    console.log('');
  }

  /**
   * Generate summary report
   */
  generateSummary() {
    console.log('üìä Configuration Update Summary\n');
    
    let totalAdded = 0;
    let totalRemoved = 0;
    let totalSources = 0;
    
    for (const [configFile, changes] of this.changes) {
      console.log(`üìù ${configFile}:`);
      console.log(`   Sources updated: ${changes.sources.length}`);
      console.log(`   Channels added: ${changes.added.length}`);
      console.log(`   Channels removed: ${changes.removed.length}`);
      
      totalAdded += changes.added.length;
      totalRemoved += changes.removed.length;
      totalSources += changes.sources.length;
      console.log('');
    }
    
    console.log(`üéØ Overall Changes:`);
    console.log(`   üìÑ Configuration files updated: ${this.changes.size}`);
    console.log(`   üîå Discord sources updated: ${totalSources}`);
    console.log(`   ‚ûï Total channels added: ${totalAdded}`);
    console.log(`   ‚ûñ Total channels removed: ${totalRemoved}`);
    console.log(`   üîÑ Net channel change: ${totalAdded - totalRemoved > 0 ? '+' : ''}${totalAdded - totalRemoved}`);
  }
}

/**
 * Main execution function
 */
async function main() {
  const updater = new ConfigUpdater();

  try {
    console.log(`üöÄ Configuration Update Tool ${updater.dryRun ? '(DRY RUN MODE)' : ''}\n`);
    
    // Parse checklist
    const guildChannels = updater.parseChecklist();
    
    // Load configurations
    const configs = updater.loadConfigs();
    
    if (configs.size === 0) {
      console.log('‚ùå No Discord configurations found to update');
      process.exit(1);
    }
    
    // Update configurations
    const hasChanges = updater.updateConfigs(guildChannels, configs);
    
    if (!hasChanges) {
      console.log('‚úÖ Configuration update complete (no changes needed)');
      return;
    }
    
    if (updater.dryRun) {
      console.log('üß™ DRY RUN: No files were actually modified');
      updater.generateSummary();
      console.log('\nüí° Run without --dry-run to apply these changes');
      return;
    }
    
    // Create backups and save
    updater.createBackup(configs);
    updater.saveConfigs(configs);
    
    // Generate summary
    updater.generateSummary();
    
    console.log('\n‚ú® Configuration update complete!');
    console.log('\nüìã Next steps:');
    console.log('1. Review the updated configuration files');
    console.log('2. Test your data collection with the new channel selections');
    console.log('3. Commit the changes to your repository');
    
  } catch (error) {
    console.error(`\n‚ùå Update failed: ${error.message}`);
    process.exit(1);
  }
}

// Handle graceful shutdown
process.on('SIGINT', () => {
  console.log('\nüëã Update cancelled by user');
  process.exit(0);
});

if (require.main === module) {
  main();
}