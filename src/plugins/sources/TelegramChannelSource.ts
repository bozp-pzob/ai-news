// src/plugins/sources/TelegramChannelSource.ts

import { ContentSource } from "./ContentSource";
import { ContentItem, AiProvider } from "../../types";
import { TelegramClient, Api } from "telegram";
import { StringSession } from "telegram/sessions";
//@ts-ignore
import input from "input";
import { groupMessagesByUtcDay } from "../../helpers/generalHelper";

interface TelegramChannelSourceConfig {
  name: string;
  apiId: string;
  apiHash: string;
  sessionString?: string;
  channels: string[]; // Telegram channels (IDs)
  provider: AiProvider | undefined;
  maxCharactersPerChunk?: number;
  numberOfMessagesPerFetch?: number;
}

export class TelegramChannelSource implements ContentSource {
  public name: string;
  public provider: AiProvider | undefined;
  private client: TelegramClient;
  private channels: string[];
  private lastProcessed: { [channelId: string]: number };
  private maxCharactersPerChunk: number = 2000;
  private numberOfMessagesPerFetch: number = 200;

  constructor(config: TelegramChannelSourceConfig) {
    this.name = config.name;
    this.provider = config.provider;
    this.channels = config.channels;
    this.lastProcessed = {};
    this.maxCharactersPerChunk = config.maxCharactersPerChunk || this.maxCharactersPerChunk;
    this.numberOfMessagesPerFetch = config.numberOfMessagesPerFetch || this.numberOfMessagesPerFetch;

    if (! config.sessionString) {
        throw("TelegramChannelSource Session String must be generated by running `npm run createToken`. \n\nToken is stored as a string which should be stored in the environment variable TELEGRAM_SESSION")
    }

    const stringSession = new StringSession(config.sessionString || "");
    this.client = new TelegramClient(
      stringSession,
      parseInt(config.apiId),
      config.apiHash,
      {
        connectionRetries: 5,
        deviceModel: "Telegram Web",
        systemVersion: "Unknown",
        appVersion: "7.8.3",
        langCode: "en",
      }
    );
  }

  public async start(): Promise<void> {
    await this.client.start({
      phoneNumber: async () =>
        await input.text("Please enter your phone number: "),
      password: async () =>
        await input.text("Please enter your password: "),
      phoneCode: async () =>
        await input.text("Please enter the code you received: "),
      onError: (err) =>
        console.log(
          "Telegram Channel Source Error: Refetch Session String using createToken Driver."
        ),
    });
  }

  private isEndOfCurrentUtcDay(): boolean {
    const now = new Date();
    const utcHour = now.getUTCHours();
    const utcMinute = now.getUTCMinutes();
    return utcHour === 23 && utcMinute >= 55;
  }

  public async fetchItems(): Promise<ContentItem[]> {
    await this.start();

    let telegramResponse: ContentItem[] = [];
    const currentUtcDay = new Date().toISOString().split("T")[0];

    for (const channelId of this.channels) {
      const messages = await this.client.getMessages(channelId, {
        limit: this.numberOfMessagesPerFetch,
        offsetId: 0,
        filter: new Api.InputMessagesFilterEmpty(),
      });

      if (!messages || messages.length === 0) {
        console.log(`No new messages for channel ${channelId}.`);
        continue;
      }

      messages.sort((a, b) => a.id - b.id);
      const grouped = groupMessagesByUtcDay(messages);

      for (const day in grouped) {
        const dayMessages = grouped[day];
        let accumulatedTranscript = "";
        let chunkIndex = 0;
        const dayTimestamp = Math.floor(new Date(day).getTime() / 1000);

        for (let i = 0; i < dayMessages.length; i++) {
          const msg = dayMessages[i];
          let senderName = "Unknown";
          try {
            //@ts-ignore
            const sender = await this.client.getEntity(msg.senderId);
            senderName =
              (sender as any).username ||
              (sender as any).firstName ||
              "Unknown";
          } catch (err) {
            console.error("Error fetching sender entity:", err);
          }
          const line = `[${senderName}]: ${msg.message}\n`;

          if (
            accumulatedTranscript.length + line.length >= this.maxCharactersPerChunk &&
            accumulatedTranscript.length > 0
          ) {
            const prompt = this.formatStructuredPrompt(accumulatedTranscript);
            if (this.provider) {
              try {
                const summary = await this.provider.summarize(prompt);
                telegramResponse.push({
                  type: "telegramChannelSummary",
                  cid: `${channelId}-${day}-chunk${chunkIndex}`,
                  source: this.name,
                  text: summary,
                  link: `https://t.me/${channelId}`,
                  date: dayTimestamp,
                  metadata: {
                    channelId: channelId,
                    summaryDate: Math.floor(Date.now() / 1000),
                    day: day,
                    chunk: chunkIndex,
                  },
                });
                chunkIndex++;
              } catch (err) {
                console.error("Error summarizing chunk:", err);
              }
            }
            accumulatedTranscript = "";
          }
          accumulatedTranscript += line;
        }
        if (
          accumulatedTranscript.length > 0 &&
          (day !== currentUtcDay || (day === currentUtcDay && this.isEndOfCurrentUtcDay()))
        ) {
          const prompt = this.formatStructuredPrompt(accumulatedTranscript);
          if (this.provider) {
            try {
              const summary = await this.provider.summarize(prompt);
              telegramResponse.push({
                type: "telegramChannelSummary",
                cid: `${channelId}-${day}-chunk${chunkIndex}`,
                source: this.name,
                text: summary,
                link: `https://t.me/${channelId}`,
                date: dayTimestamp,
                metadata: {
                  channelId: channelId,
                  summaryDate: Math.floor(Date.now() / 1000),
                  day: day,
                  chunk: chunkIndex,
                },
              });
            } catch (err) {
              console.error("Error summarizing final chunk:", err);
            }
          }
        }
      }
      const lastMsg = messages[messages.length - 1];
      this.lastProcessed[channelId] = lastMsg.id;
    }
    
    return telegramResponse;
  }

  public async fetchHistorical(date: string): Promise<ContentItem[]> {
    await this.start();

    const targetTimestamp = Math.floor(new Date(date).getTime() / 1000);
    const fetchUntilTimestamp = targetTimestamp - 60;
    let telegramResponse: ContentItem[] = [];

    for (const channelId of this.channels) {
      let allMessages: any[] = [];
      let offsetId = 0;

      while (true) {
        const messages = await this.client.getMessages(channelId, {
          limit: this.numberOfMessagesPerFetch,
          offsetId,
          filter: new Api.InputMessagesFilterEmpty(),
        });
        if (!messages || messages.length === 0) break;

        for (const msg of messages) {
          const msgTimestamp = Math.floor(msg.date);
          if (msgTimestamp >= fetchUntilTimestamp) {
            allMessages.push(msg);
          } else {
            break;
          }
        }

        offsetId = messages[messages.length - 1].id;
        const lastMsgTimestamp = Math.floor(messages[messages.length - 1].date);
        if (lastMsgTimestamp < fetchUntilTimestamp) break;
      }

      if (allMessages.length === 0) {
        console.log(
          `No historical messages for channel ${channelId} since ${date}.`
        );
        continue;
      }

      allMessages.sort((a, b) => a.id - b.id);
      const grouped = groupMessagesByUtcDay(allMessages);

      for (const day in grouped) {
        const dayMessages = grouped[day];
        let accumulatedTranscript = "";
        let chunkIndex = 0;
        const dayTimestamp = Math.floor(new Date(day).getTime() / 1000);

        for (let i = 0; i < dayMessages.length; i++) {
          const msg = dayMessages[i];
          let senderName = "Unknown";
          try {
            const sender = await this.client.getEntity(msg.senderId);
            senderName =
              (sender as any).username ||
              (sender as any).firstName ||
              "Unknown";
          } catch (err) {
            console.error("Error fetching sender entity:", err);
          }
          const line = `[${senderName}]: ${msg.message}\n`;

          if (
            accumulatedTranscript.length + line.length >= this.maxCharactersPerChunk &&
            accumulatedTranscript.length > 0
          ) {
            const prompt = this.formatStructuredPrompt(accumulatedTranscript);
            if (this.provider) {
              try {
                const summary = await this.provider.summarize(prompt);
                telegramResponse.push({
                  type: "telegramChannelHistoricalSummary",
                  cid: `${channelId}-historical-${day}-chunk${chunkIndex}`,
                  source: this.name,
                  text: summary,
                  link: `https://t.me/${channelId}`,
                  date: dayTimestamp,
                  metadata: {
                    channelId,
                    summaryDate: dayTimestamp,
                    historicalSince: date,
                    day,
                    chunk: chunkIndex,
                  },
                });
                chunkIndex++;
              } catch (err) {
                console.error("Error summarizing historical chunk:", err);
              }
            }
            accumulatedTranscript = "";
          }
          accumulatedTranscript += line;
        }

        if (accumulatedTranscript.length > 0) {
          const prompt = this.formatStructuredPrompt(accumulatedTranscript);
          if (this.provider) {
            try {
              const summary = await this.provider.summarize(prompt);
              telegramResponse.push({
                type: "telegramChannelHistoricalSummary",
                cid: `${channelId}-historical-${day}-chunk${chunkIndex}`,
                source: this.name,
                text: summary,
                link: `https://t.me/${channelId}`,
                date: dayTimestamp,
                metadata: {
                  channelId,
                  summaryDate: dayTimestamp,
                  historicalSince: date,
                  day,
                  chunk: chunkIndex,
                },
              });
            } catch (err) {
              console.error("Error summarizing final historical chunk:", err);
            }
          }
        }
      }
    }
    return telegramResponse;
  }

  public async createToken(): Promise<string> {
    await this.client.start({
      phoneNumber: async () =>
        await input.text("Please enter your phone number: "),
      password: async () =>
        await input.text("Please enter your password: "),
      phoneCode: async () =>
        await input.text("Please enter the code you received: "),
      onError: (err) => console.log(err),
    });
    console.log("Telegram client connected.");
    const session = await this.client.session.save();
    console.log(`Telegram Session String: ${session}`);
    return "";
  }

  private formatStructuredPrompt(transcript: string): string {
    return `Analyze this Telegram chat segment and provide a succinct analysis:
            
1. Summary (max 500 words):
- Focus ONLY on the most important technical discussions, decisions, and problem-solving.
- Highlight concrete solutions and implementations.
- Be specific and VERY concise.

2. FAQ (max 20 questions):
- Only include the most significant questions that got meaningful responses.
- Focus on unique questions, skip similar or rhetorical questions.
- Include who asked the question and who answered.
- Use the exact Telegram username from the chat.

3. Help Interactions (max 10):
- List the significant instances where community members helped each other.
- Be specific and concise about what kind of help was given.
- Include context about the problem that was solved.
- Mention if the help was successful.

4. Action Items (max 20 total):
- Technical Tasks: Critical development tasks only.
- Documentation Needs: Essential doc updates only.
- Feature Requests: Major feature suggestions only.

For each action item, include:
- Clear description.
- Who mentioned it.

Chat transcript:
${transcript}

Return the analysis in the specified structured format. Be specific about technical content and avoid duplicating information.`;
  }
}
